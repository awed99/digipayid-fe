import { _optionalChain } from '@sentry/utils';
import { applySdkMetadata, getGlobalScope, getClient, spanToJSON, getRootSpan, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '@sentry/core';
import { getDefaultIntegrations, init as init$1 } from '@sentry/node';
export * from '@sentry/node';
import { logger, GLOBAL_OBJ } from '@sentry/utils';
import { SEMATTRS_HTTP_TARGET, ATTR_HTTP_REQUEST_METHOD, SEMATTRS_HTTP_METHOD, ATTR_HTTP_ROUTE } from '@opentelemetry/semantic-conventions';
import { DEBUG_BUILD } from '../common/debug-build.js';
import { devErrorSymbolicationEventProcessor } from '../common/devErrorSymbolicationEventProcessor.js';
import { getVercelEnv } from '../common/getVercelEnv.js';
import { isBuild } from '../common/utils/isBuild.js';
import { distDirRewriteFramesIntegration } from './distDirRewriteFramesIntegration.js';
export { captureUnderscoreErrorException } from '../common/_error.js';
export { wrapGetStaticPropsWithSentry } from '../common/wrapGetStaticPropsWithSentry.js';
export { wrapGetInitialPropsWithSentry } from '../common/wrapGetInitialPropsWithSentry.js';
export { wrapAppGetInitialPropsWithSentry } from '../common/wrapAppGetInitialPropsWithSentry.js';
export { wrapDocumentGetInitialPropsWithSentry } from '../common/wrapDocumentGetInitialPropsWithSentry.js';
export { wrapErrorGetInitialPropsWithSentry } from '../common/wrapErrorGetInitialPropsWithSentry.js';
export { wrapGetServerSidePropsWithSentry } from '../common/wrapGetServerSidePropsWithSentry.js';
export { wrapServerComponentWithSentry } from '../common/wrapServerComponentWithSentry.js';
export { wrapRouteHandlerWithSentry } from '../common/wrapRouteHandlerWithSentry.js';
export { wrapApiHandlerWithSentryVercelCrons } from '../common/wrapApiHandlerWithSentryVercelCrons.js';
export { wrapMiddlewareWithSentry } from '../common/wrapMiddlewareWithSentry.js';
export { wrapPageComponentWithSentry } from '../common/wrapPageComponentWithSentry.js';
export { wrapGenerationFunctionWithSentry } from '../common/wrapGenerationFunctionWithSentry.js';
export { withServerActionInstrumentation } from '../common/withServerActionInstrumentation.js';
export { captureRequestError, experimental_captureRequestError } from '../common/captureRequestError.js';
export { wrapApiHandlerWithSentry } from '../common/wrapApiHandlerWithSentry.js';

const globalWithInjectedValues = GLOBAL_OBJ

;

// https://github.com/lforst/nextjs-fork/blob/9051bc44d969a6e0ab65a955a2fc0af522a83911/packages/next/src/server/lib/trace/constants.ts#L11
const NEXTJS_SPAN_NAME_PREFIXES = [
  'BaseServer.',
  'LoadComponents.',
  'NextServer.',
  'createServer.',
  'startServer.',
  'NextNodeServer.',
  'Render.',
  'AppRender.',
  'Router.',
  'Node.',
  'AppRouteRouteHandlers.',
  'ResolveMetadata.',
];

/**
 * A passthrough error boundary for the server that doesn't depend on any react. Error boundaries don't catch SSR errors
 * so they should simply be a passthrough.
 */
const ErrorBoundary = (props) => {
  if (!props.children) {
    return null;
  }

  if (typeof props.children === 'function') {
    return (props.children )();
  }

  // since Next.js >= 10 requires React ^16.6.0 we are allowed to return children like this here
  return props.children ;
};

/**
 * A passthrough redux enhancer for the server that doesn't depend on anything from the `@sentry/react` package.
 */
function createReduxEnhancer() {
  return (createStore) => createStore;
}

/**
 * A passthrough error boundary wrapper for the server that doesn't depend on any react. Error boundaries don't catch
 * SSR errors so they should simply be a passthrough.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function withErrorBoundary(
  WrappedComponent,
) {
  return WrappedComponent ;
}

/**
 * Just a passthrough since we're on the server and showing the report dialog on the server doesn't make any sense.
 */
function showReportDialog() {
  return;
}

/** Inits the Sentry NextJS SDK on node. */
function init(options) {
  if (isBuild()) {
    return;
  }

  const customDefaultIntegrations = getDefaultIntegrations(options);

  // Turn off Next.js' own fetch instrumentation
  // https://github.com/lforst/nextjs-fork/blob/1994fd186defda77ad971c36dc3163db263c993f/packages/next/src/server/lib/patch-fetch.ts#L245
  process.env.NEXT_OTEL_FETCH_DISABLED = '1';

  // This value is injected at build time, based on the output directory specified in the build config. Though a default
  // is set there, we set it here as well, just in case something has gone wrong with the injection.
  const distDirName = globalWithInjectedValues.__rewriteFramesDistDir__;
  if (distDirName) {
    customDefaultIntegrations.push(distDirRewriteFramesIntegration({ distDirName }));
  }

  const opts = {
    environment: process.env.SENTRY_ENVIRONMENT || getVercelEnv(false) || process.env.NODE_ENV,
    defaultIntegrations: customDefaultIntegrations,
    ...options,
    // Right now we only capture frontend sessions for Next.js
    autoSessionTracking: false,
  };

  if (DEBUG_BUILD && opts.debug) {
    logger.enable();
  }

  DEBUG_BUILD && logger.log('Initializing SDK...');

  if (sdkAlreadyInitialized()) {
    DEBUG_BUILD && logger.log('SDK already initialized');
    return;
  }

  applySdkMetadata(opts, 'nextjs', ['nextjs', 'node']);

  const client = init$1(opts);
  _optionalChain([client, 'optionalAccess', _ => _.on, 'call', _2 => _2('beforeSampling', ({ spanAttributes, spanName, parentSampled, parentContext }, samplingDecision) => {
    // We allowlist the "BaseServer.handleRequest" span, since that one is responsible for App Router requests, which are actually useful for us.
    // HOWEVER, that span is not only responsible for App Router requests, which is why we additionally filter for certain transactions in an
    // event processor further below.
    if (spanAttributes['next.span_type'] === 'BaseServer.handleRequest') {
      return;
    }

    // If we encounter a span emitted by Next.js, we do not want to sample it
    // The reason for this is that the data quality of the spans varies, it is different per version of Next,
    // and we need to keep our manual instrumentation around for the edge runtime anyhow.
    // BUT we only do this if we don't have a parent span with a sampling decision yet (or if the parent is remote)
    if (
      (spanAttributes['next.span_type'] || NEXTJS_SPAN_NAME_PREFIXES.some(prefix => spanName.startsWith(prefix))) &&
      (parentSampled === undefined || _optionalChain([parentContext, 'optionalAccess', _3 => _3.isRemote]))
    ) {
      samplingDecision.decision = false;
    }

    // There are situations where the Next.js Node.js server forwards requests for the Edge Runtime server (e.g. in
    // middleware) and this causes spans for Sentry ingest requests to be created. These are not exempt from our tracing
    // because we didn't get the chance to do `suppressTracing`, since this happens outside of userland.
    // We need to drop these spans.
    if (
      // eslint-disable-next-line deprecation/deprecation
      typeof spanAttributes[SEMATTRS_HTTP_TARGET] === 'string' &&
      // eslint-disable-next-line deprecation/deprecation
      spanAttributes[SEMATTRS_HTTP_TARGET].includes('sentry_key') &&
      // eslint-disable-next-line deprecation/deprecation
      spanAttributes[SEMATTRS_HTTP_TARGET].includes('sentry_client')
    ) {
      samplingDecision.decision = false;
    }
  })]);

  _optionalChain([client, 'optionalAccess', _4 => _4.on, 'call', _5 => _5('spanStart', span => {
    const spanAttributes = spanToJSON(span).data;

    // What we do in this glorious piece of code, is hoist any information about parameterized routes from spans emitted
    // by Next.js via the `next.route` attribute, up to the transaction by setting the http.route attribute.
    if (_optionalChain([spanAttributes, 'optionalAccess', _6 => _6['next.route']])) {
      const rootSpan = getRootSpan(span);
      const rootSpanAttributes = spanToJSON(rootSpan).data;

      // Only hoist the http.route attribute if the transaction doesn't already have it
      if (
        // eslint-disable-next-line deprecation/deprecation
        (_optionalChain([rootSpanAttributes, 'optionalAccess', _7 => _7[ATTR_HTTP_REQUEST_METHOD]]) || _optionalChain([rootSpanAttributes, 'optionalAccess', _8 => _8[SEMATTRS_HTTP_METHOD]])) &&
        !_optionalChain([rootSpanAttributes, 'optionalAccess', _9 => _9[ATTR_HTTP_ROUTE]])
      ) {
        rootSpan.setAttribute(ATTR_HTTP_ROUTE, spanAttributes['next.route']);
      }
    }

    // We want to skip span data inference for any spans generated by Next.js. Reason being that Next.js emits spans
    // with patterns (e.g. http.server spans) that will produce confusing data.
    if (_optionalChain([spanAttributes, 'optionalAccess', _10 => _10['next.span_type']]) !== undefined) {
      span.setAttribute('sentry.skip_span_data_inference', true);
    }

    // We want to rename these spans because they look like "GET /path/to/route" and we already emit spans that look
    // like this with our own http instrumentation.
    if (_optionalChain([spanAttributes, 'optionalAccess', _11 => _11['next.span_type']]) === 'BaseServer.handleRequest') {
      span.updateName('next server handler'); // This is all lowercase because the spans that Next.js emits by itself generally look like this.
    }
  })]);

  getGlobalScope().addEventProcessor(
    Object.assign(
      (event => {
        if (event.type === 'transaction') {
          // Filter out transactions for static assets
          // This regex matches the default path to the static assets (`_next/static`) and could potentially filter out too many transactions.
          // We match `/_next/static/` anywhere in the transaction name because its location may change with the basePath setting.
          if (_optionalChain([event, 'access', _12 => _12.transaction, 'optionalAccess', _13 => _13.match, 'call', _14 => _14(/^GET (\/.*)?\/_next\/static\//)])) {
            return null;
          }

          // We only want to use our HTTP integration/instrumentation for app router requests, which are marked with the `sentry.rsc` attribute.
          if (
            (_optionalChain([event, 'access', _15 => _15.contexts, 'optionalAccess', _16 => _16.trace, 'optionalAccess', _17 => _17.data, 'optionalAccess', _18 => _18[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]]) === 'auto.http.otel.http' ||
              _optionalChain([event, 'access', _19 => _19.contexts, 'optionalAccess', _20 => _20.trace, 'optionalAccess', _21 => _21.data, 'optionalAccess', _22 => _22['next.span_type']]) === 'BaseServer.handleRequest') &&
            _optionalChain([event, 'access', _23 => _23.contexts, 'optionalAccess', _24 => _24.trace, 'optionalAccess', _25 => _25.data, 'optionalAccess', _26 => _26['sentry.rsc']]) !== true
          ) {
            return null;
          }

          // Filter out transactions for requests to the tunnel route
          if (
            globalWithInjectedValues.__sentryRewritesTunnelPath__ &&
            event.transaction === `POST ${globalWithInjectedValues.__sentryRewritesTunnelPath__}`
          ) {
            return null;
          }

          // Filter out requests to resolve source maps for stack frames in dev mode
          if (_optionalChain([event, 'access', _27 => _27.transaction, 'optionalAccess', _28 => _28.match, 'call', _29 => _29(/\/__nextjs_original-stack-frame/)])) {
            return null;
          }

          // Filter out /404 transactions which seem to be created excessively
          if (
            // Pages router
            event.transaction === '/404' ||
            // App router (could be "GET /404", "POST /404", ...)
            _optionalChain([event, 'access', _30 => _30.transaction, 'optionalAccess', _31 => _31.match, 'call', _32 => _32(/^(GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH) \/404$/)]) ||
            event.transaction === 'GET /_not-found'
          ) {
            return null;
          }

          return event;
        } else {
          return event;
        }
      }) ,
      { id: 'NextLowQualityTransactionsFilter' },
    ),
  );

  getGlobalScope().addEventProcessor(
    Object.assign(
      ((event, hint) => {
        if (event.type !== undefined) {
          return event;
        }

        const originalException = hint.originalException;

        const isPostponeError =
          typeof originalException === 'object' &&
          originalException !== null &&
          '$$typeof' in originalException &&
          originalException.$$typeof === Symbol.for('react.postpone');

        if (isPostponeError) {
          // Postpone errors are used for partial-pre-rendering (PPR)
          return null;
        }

        // We don't want to capture suspense errors as they are simply used by React/Next.js for control flow
        const exceptionMessage = _optionalChain([event, 'access', _33 => _33.exception, 'optionalAccess', _34 => _34.values, 'optionalAccess', _35 => _35[0], 'optionalAccess', _36 => _36.value]);
        if (
          _optionalChain([exceptionMessage, 'optionalAccess', _37 => _37.includes, 'call', _38 => _38('Suspense Exception: This is not a real error!')]) ||
          _optionalChain([exceptionMessage, 'optionalAccess', _39 => _39.includes, 'call', _40 => _40('Suspense Exception: This is not a real error, and should not leak')])
        ) {
          return null;
        }

        return event;
      }) ,
      { id: 'DropReactControlFlowErrors' },
    ),
  );

  if (process.env.NODE_ENV === 'development') {
    getGlobalScope().addEventProcessor(devErrorSymbolicationEventProcessor);
  }

  DEBUG_BUILD && logger.log('SDK successfully initialized');

  return client;
}

function sdkAlreadyInitialized() {
  return !!getClient();
}

export { ErrorBoundary, createReduxEnhancer, init, showReportDialog, withErrorBoundary };
//# sourceMappingURL=index.js.map
