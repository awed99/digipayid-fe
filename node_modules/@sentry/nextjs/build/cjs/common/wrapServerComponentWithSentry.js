var {
  _nullishCoalesce,
  _optionalChain
} = require('@sentry/utils');

Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const utils = require('@sentry/utils');
const nextNavigationErrorUtils = require('./nextNavigationErrorUtils.js');
const responseEnd = require('./utils/responseEnd.js');
const tracingUtils = require('./utils/tracingUtils.js');
const vercelWaitUntil = require('./utils/vercelWaitUntil.js');

/**
 * Wraps an `app` directory server component with Sentry error instrumentation.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function wrapServerComponentWithSentry(
  appDirComponent,
  context,
) {
  const { componentRoute, componentType } = context;
  // Even though users may define server components as async functions, for the client bundles
  // Next.js will turn them into synchronous functions and it will transform any `await`s into instances of the `use`
  // hook. ðŸ¤¯
  return new Proxy(appDirComponent, {
    apply: (originalFunction, thisArg, args) => {
      const requestTraceId = _optionalChain([core.getActiveSpan, 'call', _ => _(), 'optionalAccess', _2 => _2.spanContext, 'call', _3 => _3(), 'access', _4 => _4.traceId]);
      const isolationScope = tracingUtils.commonObjectToIsolationScope(context.headers);

      const activeSpan = core.getActiveSpan();
      if (activeSpan) {
        const rootSpan = core.getRootSpan(activeSpan);
        const { scope } = core.getCapturedScopesOnSpan(rootSpan);
        core.setCapturedScopesOnSpan(rootSpan, _nullishCoalesce(scope, () => ( new core.Scope())), isolationScope);

        // We mark the root span as an app router span so we can allow-list it in our span processor that would normally filter out all Next.js transactions/spans
        rootSpan.setAttribute('sentry.rsc', true);
      }

      const headersDict = context.headers ? utils.winterCGHeadersToDict(context.headers) : undefined;

      isolationScope.setSDKProcessingMetadata({
        request: {
          headers: headersDict,
        },
      });

      return core.withIsolationScope(isolationScope, () => {
        return core.withScope(scope => {
          scope.setTransactionName(`${componentType} Server Component (${componentRoute})`);

          if (process.env.NEXT_RUNTIME === 'edge') {
            const propagationContext = tracingUtils.commonObjectToPropagationContext(
              context.headers,
              _optionalChain([headersDict, 'optionalAccess', _5 => _5['sentry-trace']])
                ? utils.propagationContextFromHeaders(headersDict['sentry-trace'], headersDict['baggage'])
                : {
                    traceId: requestTraceId || utils.uuid4(),
                    spanId: utils.uuid4().substring(16),
                  },
            );

            scope.setPropagationContext(propagationContext);
          }

          return core.startSpanManual(
            {
              op: 'function.nextjs',
              name: `${componentType} Server Component (${componentRoute})`,
              attributes: {
                [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'component',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs',
              },
            },
            span => {
              return core.handleCallbackErrors(
                () => originalFunction.apply(thisArg, args),
                error => {
                  // When you read this code you might think: "Wait a minute, shouldn't we set the status on the root span too?"
                  // The answer is: "No." - The status of the root span is determined by whatever status code Next.js decides to put on the response.
                  if (nextNavigationErrorUtils.isNotFoundNavigationError(error)) {
                    // We don't want to report "not-found"s
                    span.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'not_found' });
                  } else if (nextNavigationErrorUtils.isRedirectNavigationError(error)) {
                    // We don't want to report redirects
                    span.setStatus({ code: core.SPAN_STATUS_OK });
                  } else {
                    span.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'internal_error' });
                    core.captureException(error, {
                      mechanism: {
                        handled: false,
                      },
                    });
                  }
                },
                () => {
                  span.end();
                  vercelWaitUntil.vercelWaitUntil(responseEnd.flushSafelyWithTimeout());
                },
              );
            },
          );
        });
      });
    },
  });
}

exports.wrapServerComponentWithSentry = wrapServerComponentWithSentry;
//# sourceMappingURL=wrapServerComponentWithSentry.js.map
