{"version":3,"file":"static/chunks/pages/_error-355a7c46f62b49bc456e.js","mappings":"wlBASAA,eAAeC,EAAgCC,GAC7C,MAAM,IAAEC,EAAG,IAAEC,EAAG,IAAEC,GAAQH,EAGpBI,EAAcF,GAAOA,EAAIE,YAAeJ,EAAeI,WAC7D,OAAIA,GAAcA,EAAa,IACtBC,QAAQC,UAUZN,EAAeO,WAIpB,SAAUC,IACJP,GACFO,EAAMC,yBAAyB,CAAEC,QAAST,KAK5C,QAAiBE,GAAO,sCAAsCA,KAAQ,CACpEQ,UAAW,CACTC,KAAM,aACNC,SAAS,EACTC,KAAM,CACJC,SAAU,qCCjCpB,SAAyBC,GACvB,MAAMC,EAEJ,IAAWC,OAAOC,IAAI,4BAElBC,GAAM,EAAAC,EAAA,IAAiB,EAAAC,EAAA,GAAe,CAACL,EAA4B,iBAAkBM,GAAKA,EAAEC,IAAK,eAAgBC,GAAMA,OAAQ,KAAM,OAC3I,EAAAH,EAAA,GAAe,CAACF,EAAK,SAAUM,GAAMA,EAAGC,UAAW,eAAgBC,GAAMA,EAAGZ,KDiC5Ea,CEFF/B,iBACE,IACE,KAAegC,EAAA,GAAAC,IAAW,4BACpB,QAAM,KACZ,KAAeD,EAAA,GAAAC,IAAW,wBAC1B,MAAOC,GACP,KAAeF,EAAA,GAAAC,IAAW,iCAAkCC,IFJ9CC,KArBP5B,QAAQC,U,0BGvBb4B,EAAuB,SAAAC,GAC3B,OAAO,SAAC,UAAD,CAAO/B,WAAY+B,EAAM/B,cAGlC8B,EAAqBE,gBAArB,mCAAuC,WAAMC,GAAN,iFAG/BC,EAAuCD,GAHR,gCAM9BE,EAAAA,QAAAA,gBAAsBF,IANQ,2CAAvC,sDASA,S,uBCfKG,OAAOC,SAAWD,OAAOC,UAAY,IAAIC,KAAK,CAC7C,UACA,WACE,OAAO,EAAQ,W,sBCJvBC,EAAOC,QAAU,EAAjB,Q","sources":["webpack://_N_E/./node_modules/@sentry/nextjs/build/esm/common/_error.js","webpack://_N_E/./node_modules/@sentry/nextjs/build/esm/common/utils/vercelWaitUntil.js","webpack://_N_E/./node_modules/@sentry/nextjs/build/esm/common/utils/responseEnd.js","webpack://_N_E/./src/pages/_error.jsx","webpack://_N_E/?fccd","webpack://_N_E/./node_modules/next/error.js"],"sourcesContent":["import { withScope, captureException } from '@sentry/core';\nimport { flushSafelyWithTimeout } from './utils/responseEnd.js';\nimport { vercelWaitUntil } from './utils/vercelWaitUntil.js';\n\n/**\n * Capture the exception passed by nextjs to the `_error` page, adding context data as appropriate.\n *\n * @param contextOrProps The data passed to either `getInitialProps` or `render` by nextjs\n */\nasync function captureUnderscoreErrorException(contextOrProps) {\n  const { req, res, err } = contextOrProps;\n\n  // 404s (and other 400-y friends) can trigger `_error`, but we don't want to send them to Sentry\n  const statusCode = (res && res.statusCode) || contextOrProps.statusCode;\n  if (statusCode && statusCode < 500) {\n    return Promise.resolve();\n  }\n\n  // In previous versions of the suggested `_error.js` page in which this function is meant to be used, there was a\n  // workaround for https://github.com/vercel/next.js/issues/8592 which involved an extra call to this function, in the\n  // custom error component's `render` method, just in case it hadn't been called by `getInitialProps`. Now that that\n  // issue has been fixed, the second call is unnecessary, but since it lives in user code rather than our code, users\n  // have to be the ones to get rid of it, and guaraneteedly, not all of them will. So, rather than capture the error\n  // twice, we just bail if we sense we're in that now-extraneous second call. (We can tell which function we're in\n  // because Nextjs passes `pathname` to `getInitialProps` but not to `render`.)\n  if (!contextOrProps.pathname) {\n    return Promise.resolve();\n  }\n\n  withScope(scope => {\n    if (req) {\n      scope.setSDKProcessingMetadata({ request: req });\n    }\n\n    // If third-party libraries (or users themselves) throw something falsy, we want to capture it as a message (which\n    // is what passing a string to `captureException` will wind up doing)\n    captureException(err || `_error.js called with falsy error (${err})`, {\n      mechanism: {\n        type: 'instrument',\n        handled: false,\n        data: {\n          function: '_error.getInitialProps',\n        },\n      },\n    });\n  });\n\n  vercelWaitUntil(flushSafelyWithTimeout());\n}\n\nexport { captureUnderscoreErrorException };\n//# sourceMappingURL=_error.js.map\n","import { _nullishCoalesce, _optionalChain } from '@sentry/utils';\nimport { GLOBAL_OBJ } from '@sentry/utils';\n\n/**\n * Function that delays closing of a Vercel lambda until the provided promise is resolved.\n *\n * Vendored from https://www.npmjs.com/package/@vercel/functions\n */\nfunction vercelWaitUntil(task) {\n  const vercelRequestContextGlobal =\n    // @ts-expect-error This is not typed\n    GLOBAL_OBJ[Symbol.for('@vercel/request-context')];\n\n  const ctx = _nullishCoalesce(_optionalChain([vercelRequestContextGlobal, 'optionalAccess', _ => _.get, 'optionalCall', _2 => _2()]), () => ( {}));\n  _optionalChain([ctx, 'access', _3 => _3.waitUntil, 'optionalCall', _4 => _4(task)]);\n}\n\nexport { vercelWaitUntil };\n//# sourceMappingURL=vercelWaitUntil.js.map\n","import { flush, setHttpStatus } from '@sentry/core';\nimport { logger, fill } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\n\n/**\n * Wrap `res.end()` so that it ends the span and flushes events before letting the request finish.\n *\n * Note: This wraps a sync method with an async method. While in general that's not a great idea in terms of keeping\n * things in the right order, in this case it's safe, because the native `.end()` actually *is* (effectively) async, and\n * its run actually *is* (literally) awaited, just manually so (which reflects the fact that the core of the\n * request/response code in Node by far predates the introduction of `async`/`await`). When `.end()` is done, it emits\n * the `prefinish` event, and only once that fires does request processing continue. See\n * https://github.com/nodejs/node/commit/7c9b607048f13741173d397795bac37707405ba7.\n *\n * Also note: `res.end()` isn't called until *after* all response data and headers have been sent, so blocking inside of\n * `end` doesn't delay data getting to the end user. See\n * https://nodejs.org/api/http.html#responseenddata-encoding-callback.\n *\n * @param span The span tracking the request\n * @param res: The request's corresponding response\n */\nfunction autoEndSpanOnResponseEnd(span, res) {\n  const wrapEndMethod = (origEnd) => {\n    return function sentryWrappedEnd( ...args) {\n      finishSpan(span, this);\n      return origEnd.call(this, ...args);\n    };\n  };\n\n  // Prevent double-wrapping\n  // res.end may be undefined during build when using `next export` to statically export a Next.js app\n  if (res.end && !(res.end ).__sentry_original__) {\n    fill(res, 'end', wrapEndMethod);\n  }\n}\n\n/** Finish the given response's span and set HTTP status data */\nfunction finishSpan(span, res) {\n  setHttpStatus(span, res.statusCode);\n  span.end();\n}\n\n/**\n * Flushes pending Sentry events with a 2 second timeout and in a way that cannot create unhandled promise rejections.\n */\nasync function flushSafelyWithTimeout() {\n  try {\n    DEBUG_BUILD && logger.log('Flushing events...');\n    await flush(2000);\n    DEBUG_BUILD && logger.log('Done flushing events');\n  } catch (e) {\n    DEBUG_BUILD && logger.log('Error while flushing events:\\n', e);\n  }\n}\n\nexport { autoEndSpanOnResponseEnd, finishSpan, flushSafelyWithTimeout };\n//# sourceMappingURL=responseEnd.js.map\n","import * as Sentry from '@sentry/nextjs'\nimport Error from 'next/error'\n\nconst CustomErrorComponent = props => {\n  return <Error statusCode={props.statusCode} />\n}\n\nCustomErrorComponent.getInitialProps = async contextData => {\n  // In case this is running in a serverless function, await this in order to give Sentry\n  // time to send the error before the lambda exits\n  await Sentry.captureUnderscoreErrorException(contextData)\n\n  // This will contain the status code of the response\n  return Error.getInitialProps(contextData)\n}\n\nexport default CustomErrorComponent\n","\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_error\",\n      function () {\n        return require(\"private-next-pages/_error.jsx\");\n      }\n    ]);\n  ","module.exports = require('./dist/pages/_error')\n"],"names":["async","captureUnderscoreErrorException","contextOrProps","req","res","err","statusCode","Promise","resolve","pathname","scope","setSDKProcessingMetadata","request","mechanism","type","handled","data","function","task","vercelRequestContextGlobal","Symbol","for","ctx","_nullishCoalesce","_optionalChain","_","get","_2","_3","waitUntil","_4","vercelWaitUntil","logger","log","e","flushSafelyWithTimeout","CustomErrorComponent","props","getInitialProps","contextData","Sentry","Error","window","__NEXT_P","push","module","exports"],"sourceRoot":""}